# 1 "bashor.pml"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "bashor.pml"
# 14 "bashor.pml"
typedef Direction {
        chan mutex = [1] of {bool}
        byte conflictCount;
        byte conflicts[5];
};

Direction directions[5];
bool lightState[5];
bool hasTraffic[5];

proctype trafficProc(byte id) {
        endpoint:
        do
        :: !hasTraffic[id] ->
                progress:
                hasTraffic[id] = true;
        :: hasTraffic[id] && lightState[id] == true ->
                hasTraffic[id] = false;
        od
}

proctype lightProc(byte id) {
        endpoint:
        do
        :: hasTraffic[id] ->
                directions[id].mutex ! true;;
                int i = 0;
                do
                :: i < directions[id].conflictCount ->
                        directions[directions[id].conflicts[i]].mutex ! true;;
                        i = i + 1;
                :: !(i < directions[id].conflictCount) -> break;
                od;

                lightState[id] = true;

                !hasTraffic[id];

                lightState[id] = false;

                i = directions[id].conflictCount - 1;
                do
                :: i > 0 ->
                        directions[directions[id].conflicts[i]].mutex ? true;;
                        i = i - 1;
                :: !(i > 0) -> break;
                od;
                directions[id].mutex ? true;;
        od
}
# 82 "bashor.pml"
init {
        lightState[0] = false; hasTraffic[0] = false; directions[0].conflictCount = 4; directions[0].conflicts[0] = 1; directions[0].conflicts[1] = 2; directions[0].conflicts[2] = 3; directions[0].conflicts[3] = 4;;
        lightState[1] = false; hasTraffic[1] = false; directions[1].conflictCount = 3; directions[1].conflicts[0] = 0; directions[1].conflicts[1] = 2; directions[1].conflicts[2] = 3; directions[1].conflicts[3] = 0;;
        lightState[2] = false; hasTraffic[2] = false; directions[2].conflictCount = 3; directions[2].conflicts[0] = 0; directions[2].conflicts[1] = 1; directions[2].conflicts[2] = 4; directions[2].conflicts[3] = 0;;
        lightState[3] = false; hasTraffic[3] = false; directions[3].conflictCount = 2; directions[3].conflicts[0] = 0; directions[3].conflicts[1] = 1; directions[3].conflicts[2] = 0; directions[3].conflicts[3] = 0;;
        lightState[4] = false; hasTraffic[4] = false; directions[4].conflictCount = 2; directions[4].conflicts[0] = 0; directions[4].conflicts[1] = 2; directions[4].conflicts[2] = 0; directions[4].conflicts[3] = 0;;

        run trafficProc(0); run trafficProc(1); run trafficProc(2); run trafficProc(3); run trafficProc(4);
        run lightProc(0); run lightProc(1); run lightProc(2); run lightProc(3); run lightProc(4);
}
# 104 "bashor.pml"
ltl safety {
        ([] !((lightState[0] == true) && ((lightState[1] == true) || ((lightState[2] == true) || ((lightState[3] == true) || (lightState[4] == true))))))
        && ([] !((lightState[1] == true) && ((lightState[0] == true) || ((lightState[2] == true) || (lightState[3] == true)))))
        && ([] !((lightState[2] == true) && ((lightState[0] == true) || ((lightState[1] == true) || (lightState[4] == true)))))
        && ([] !((lightState[3] == true) && ((lightState[0] == true) || (lightState[1] == true))))
        && ([] !((lightState[4] == true) && ((lightState[0] == true) || (lightState[2] == true))))
}






ltl fairness {
        [] <> !((lightState[0] == true) && hasTraffic[0]) && [] <> !((lightState[1] == true) && hasTraffic[1]) && [] <> !((lightState[2] == true) && hasTraffic[2]) && [] <> !((lightState[3] == true) && hasTraffic[3]) && [] <> !((lightState[4] == true) && hasTraffic[4]);
}

ltl liveness {
        ([] <> !((lightState[0] == true) && hasTraffic[0]) && [] <> !((lightState[1] == true) && hasTraffic[1]) && [] <> !((lightState[2] == true) && hasTraffic[2]) && [] <> !((lightState[3] == true) && hasTraffic[3]) && [] <> !((lightState[4] == true) && hasTraffic[4])) -> (([] (hasTraffic[0] && ((lightState[0] == false)) -> <> ((lightState[0] == true)))));
}
